<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Yunze's blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.101.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Yunze's blog"><link href=/posts/index.xml rel=feed type=application/rss+xml title="Yunze's blog"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://arthuryunze.github.io/posts/"><meta itemprop=name content="Posts"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Yunze's blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Posts</h1></div></div></header><main class=pb7 role=main><article class="pa3 pa4-ns nested-copy-line-height"><section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section><section class="flex-ns flex-wrap justify-around mt5"><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/my-first-post/ class="link black dim">My First Post</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">hello head here hello here</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2021-03-13-linux%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%BF%9B%E7%A8%8B/ class="link black dim">Linux命令：查看端口、进程</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">面试问题准备 Linux命令：查看端口、进程 端口：netstat -ano、lsof -i:
进程：ps -ef
管道及其他符号 &ldquo;|"：管道符号 用法:
command 1 | command 2 功能是把第一个命令command 1执行的结果作为command 2的输入传给command 2
双竖线‘||’， 用双竖线"||"分割的多条命令，执行的时候遵循如下规则，
如果前一条命令为真，则后面的命令不会执行，如果前一条命令为假，则继续执行后面的命令。
举例输入1小于2双竖线输出b，前面为真，后面不执行则没有输出b，输入1大于2双竖线echo b，前面为假则输出b。
&依次执行多条命令，不管命令是否执行成功 && 可依次执行多条命令，当碰到执行错误的命令时，将不再执行后面的命令。如果一直没有错误的，则执行完毕。 白盒测试： 是测试人员要了解程序结构和处理过程,按照程序内部逻辑测试程序,检查程序中的每条通路是否按照预定要求正确工作.它主要的针对被测程序的源代码,测试着可以完全不考虑程序的功能. *白盒测试流程:* 源程序&ndash;>分析程序内部逻辑结构&ndash;>流程图&ndash;>制定测试用例&ndash;>被测程序&ndash;>执行路径&ndash;>覆盖情况分析 黑盒测试: 是根据功能需求来测试程序是否按照预期工作,是要从用户的角度分析.尽量发现代码所表现的外部行为的错误.黑盒测试应该是由测试团队来完成的.根据某个给定的输入,应该能够理解并详细说明程序的预期输出. 黑盒测试流程: 功能需求&ndash;>产生测试用例&ndash;>被测程序&ndash;>输出实际结果&ndash;>与预期结果比较&ndash;>分析功能是否实现. 回归测试: 在对软件进行修正后进行的有选择的重新测试过程.一般要重复已用的测试用例.目的是检验软件在更改后所引起的错误,验证软件在修改后未引起不希望的有害效果.
自我介绍 如何自我介绍（语气要抑扬顿挫，神态要声情并茂，不能机械的没有感情的背） 一般人的自我介绍过于平常，只说姓名、年龄、爱好、工作经验，这些在简历上都有，其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等
您好（下午好/上午好），我15年毕业，大学所学的专业是计算机，毕业之后来到北京，一开始在一家创业型团队起步，当时主力开发语言是python，版本号我记得还很清楚是python2.7，在公司主要和业务打交道（这里可以简单谈一下主营业务，也可以不谈），大概沉淀了两年左右吧，我跳槽到了（你主要包装的第二家大厂），薪酬实现了double，在新的技术团队里，我接触到了微服务架构思想，使用thrift框架写后台接口，同时技术栈也越来越丰富，前端技术也有所涉猎，比如vue框架，先进的数据双向绑定理念，同时也学习了在业务解耦和服务封装层面比较流行的docker容器技术，这项技术使我平时开发和测试工作都提高了效率，最近一年左右吧，我经常使用的web框架是tornado,这个框架我个人非常喜欢，它的异步非阻塞特性让我对异步编程思想的认识更深入了。其实三四年下来，做过的东西解决过的问题也挺多的，待过大公司也经历过小团队，给我的感觉就是互联网企业随着发展，技术和行业边界其实是越来越模糊的，也就是说技术都是具有相通性的，我个人来讲，优势就是技术涉猎比较广，前后端都接触过，踩得坑也比较多，在特定领域有一定的深入，比如异步编程这块。另外我觉得搞开发的，学习能力，总结能力很重要，所以我一直保持着写技术博客的习惯，这样经过沉淀，可以提高一个人的分析能力，也就是解决问题的能力，我的介绍完了，谢谢。
“本人在校期间通过有关python、机器学习、深度学习、图像识别等方面的书籍以及CSDN博客、b站的视频、知乎以及七月在线机器学习课程进行学习。学习的内容流程大致为：python基础的语法&mdash;-numpy、pandas、matplotlib、time等库的应用&mdash;-常用的机器学习模型（如LR、SVM、树模型、常用的聚类算法等）&mdash;-BP神经网络&mdash;-CNN、RNN、LSTM等网络&mdash;-VGG、Resnet等物体检测backbone&mdash;-RCNN系列、Yolo系列、SSD系列物体检测方法&mdash;-近几年物体检测方向的论文等。 ———————————————— 版权声明：本文为CSDN博主「v_JULY_v」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/v_JULY_v/article/details/109991373
您好（下午好/上午好），我是河北农业大学20年毕业生，大学所学的专业是计算机科学与技术，毕业之后来
其实三四年下来，做过的东西解决过的问题也挺多的，待过大公司也经历过小团队，我个人来讲，优势就是技术涉猎比较广，前后端都接触过，踩得坑也比较多，在特定领域有一定的深入，比如异步编程这块。另外我觉得搞开发的，学习能力，总结能力很重要，所以我一直保持着写技术博客的习惯，这样经过沉淀，可以提高一个人的分析能力，也就是解决问题的能力，我的介绍完了，谢谢。
reference 实训_自我介绍以及知识点串联 | python高频面试题，以及面试话术总结
等</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2021-03-13-%E4%BD%BFgoogle%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%E8%87%AA%E5%B7%B1%E7%9A%84github-page%E5%8D%9A%E5%AE%A2/ class="link black dim">使Google搜索引擎收录自己的Github Page博客</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">使Google搜索引擎收录自己的Github Page博客 登陆Google收录地址 https://search.google.com/search-console/welcome
手动设置站点地图 选择右边网址前缀选项，填入github page地址，然后把生成的html文件放到博客index同级路径下，发布到github page，校验一下，需要等待一天左右。
reference github pages 如何被google收录 | Byte的博客</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2021-03-06-python%E7%94%9F%E6%88%90%E5%99%A8%E9%81%87%E5%88%B0loop%E5%9F%9F%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98/ class="link black dim">python生成器遇到loop域产生的问题</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">python生成器遇到loop域产生的问题 def triangles(): L = [1] while True: #为什么要加[:] yield L[:] L.append(0) if __name__ == '__main__': # [1, 9, 36, 84, 126, 126, 84, 36, 9, 1] n = 0 results = [] # 如果L不加[:]切片，会导致此for循环先运行完再进行yield，while true中的代码会先运行十次 # 导致有10个0，这应该是对L的原地址上直接进行了修改，因此要加上[:] for t in triangles(): results.append(t) n = n + 1 if n == 10: break for t in results: print(t)</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2021-03-06-%E4%B8%80%E4%BA%9Bpython%E5%9F%BA%E7%A1%80/ class="link black dim">一些python基础</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">python基础 下划线 单前导下划线 _var 约定俗成的含义
以单个下划线开头的变量或方法仅供内部使用。
即私有，这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。
前置双下划线 私有化属性或方法，无法在外部直接访问（名字重整所以访问不到,只能是允许这个类本身进行访问了。连子类也不可以）
前后双下划线 系统定义名字（这就是在python中强大的魔法方法），因为变量名__xxx__对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。
参数传递 如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值&rsquo;来传递对象。
python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。
Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。
如何在Python中创建自己的包？ Python中创建包是比较方便的，只需要在当前目录建立一个文件夹，文件夹中包含一个__init__.py文件和若干个模块文件，其中__init__.py可以是一个空文件，但还是建议将包中所有需要导出的变量放到__all__中，这样可以确保包的接口清晰明了，易于使用。
__all__ 只有以“from 模块名 import *”形式导入的模块，当该模块设有 __all__ 变量时，只能导入该变量指定的成员，未指定的成员是无法导入的。
以下两种情况__all__不起作用
以“import 模块名”的形式导入模块。 以“from 模块名 import 成员”的形式直接导入指定成员。 可变对象与不可变对象 可变对象（比如字典或者列表）
不可变对象（比如数字、字符或者元组）
不可变集合（frozenset） 集合是可变的。而不可变集合却不可变
myset=frozenset([1,3,2,2]) myset 深拷贝浅拷贝 深拷贝 开辟新的内存空间
import copy b=copy.deepcopy(a) 浅拷贝要分三种情况进行讨论 拷贝不可变对象：只是增加一个指向原对象的引用，改变会互相影响。
拷贝可变对象(一层结构)：产生新的对象，开辟新的内存空间，改变互不影响。
拷贝可变对象(多层结构)：产生新的对象，开辟新的内存空间，不改变包含的子对象则互不影响、改变包含的子对象则互相影响。
>>> import copy >>> a = [1, 2, [3, 4]] >>> b = copy.copy(a) >>> b ... [1, 2, [3, 4]] # 查看两者的内存地址，不同，开辟了新的内存空间 >>> id(b) 1833997596488 >>> id(a) 1833997596424 >>> a is b .</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2021-03-04-%E8%AE%B0%E5%BD%95%E5%AE%89%E8%A3%85cuda/ class="link black dim">记录安装cuda</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">记录安装cuda 获取下载命令： 进入官网
https://developer.nvidia.com/zh-cn/cuda-downloads
依次选择：Linux、x86、Ubuntu、20.04、runfile
获取下载命令：
wget https://developer.download.nvidia.com/compute/cuda/11.1.0/local_installers/cuda_11.1.0_455.23.05_linux.run sudo sh cuda_11.1.0_455.23.05_linux.run 安装 由于已经安装了显卡驱动，因此在安装时将驱动取消打勾。
安装完成后，显示提示。
=========== = Summary = =========== Driver: Not Selected Toolkit: Installed in /usr/local/cuda-11.1/ Samples: Installed in /home/yunze/, but missing recommended libraries Please make sure that - PATH includes /usr/local/cuda-11.1/bin - LD_LIBRARY_PATH includes /usr/local/cuda-11.1/lib64, or, add /usr/local/cuda-11.1/lib64 to /etc/ld.so.conf and run ldconfig as root To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-11.1/bin ***WARNING: Incomplete installation! This installation did not install the CUDA Driver.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2020-05-28-ubuntu+apache2+mysql8%E7%8E%AF%E5%A2%83php%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/ class="link black dim">Ubuntu+apache2+MySQL8环境PHP升级版本</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">catagories: 运维 description: LAMP安装配置 这篇文章旨在记录Ubuntu+apache2+MySQL8环境下升级PHP版本（无缝升级）的经过。
原因 因某次手贱升级了MySQL数据库（版本从5到8），导致MySQL与php的兼容出了问题。
Ubuntu阿里源安装的PHP版本是7.0.3的。这个版本的PHP是不支持MySQL8新的加密方式的（caching_sha2_password），所以PHP项目在连接数据库时就会出现连接失败的问题。phpmyadmin也无法登录。
起初以为是root的远程访问权限出了问题，因为我的root权限是只限本机的（localhost），后来通过创建新的具有远程访问权限的用户发现还是无法连接，知道了跟用户权限没关系。
（Linux再也不随便升级东西了，有些软件升级后，废弃的特性和新的特性会影响各种配置）。
解决方案 找到解决方案前尝试了
修改my.cnf，发现没有这个文件，且添加文件并修改也没有效果 修改账户密码加密方式，修改后无效果 添加PHP源，这个时候PHP版本最新是7.4版本。
add-apt-repository ppa:ondrej/php
sudo apt update
sudo apt upgrade php
sudo apt install php-mysql 安装php mysql扩展。
至此，查看phpinfo界面，发现版本还是7.0，说明服务器没有使用新的版本。
查看apache2相关配置文件后，发现php是以插件的形式存在于apache2服务器中的（在/etc apache2 中什么mods enable路径下可以找到），可以使用命令打开关闭。
关闭php7.0，开启php7.4。
sudo a2dismod php7.0
sudo a2enmod php7.4
重启apache2服务器
sudo service apache2 restart
至此，服务器上的php升级完成。phpinfo页的版本也已经更新。( •̀ ω •́ )y
Reference：
(11条消息)phpmyadmin连接MySQL8.0报错#2054 - The server requested authentication method unknown to the client_数据库_weixin_40208575的博客-CSDN博客
SHA2密码验证引起的PHP错误：SQLSTATE[HY000] [2054] The server requested authentication method unknown to the client - 有欲 - 博客园</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2020-05-16-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%95%B0%E6%8D%AE%E9%9B%86%E8%AE%AD%E7%BB%83%E9%9B%86%E9%AA%8C%E8%AF%81%E9%9B%86%E6%B5%8B%E8%AF%95%E9%9B%86/ class="link black dim">机器学习中的三种数据集：训练集、验证集、测试集</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">categories: ML description: dataset 机器学习中的数据集 训练集、验证集、测试集 在人工智能技术中，通常有三种常用的数据集：训练集、验证集、测试集。
先用一个不恰当的比喻来说明3种数据集之间的关系：
训练集相当于上课学知识 验证集相当于课后的的练习题，用来纠正和强化学到的知识 测试集相当于期末考试，用来最终评估学习效果 训练集 训练集（Training Dataset）是用来训练模型使用的。
机器学习的七个步骤 验证集 当我们的模型训练好之后，我们并不知道他的表现如何。
这个时候就可以使用验证集（Validation Dataset）来看看模型在新数据（验证集和测试集是不同的数据）上的表现如何。同时通过调整超参数，让模型处于最好的状态。
验证集有2个主要的作用：
评估模型效果，为了调整超参数而服务 调整超参数，使得模型在验证集上的效果最好 说明：
验证集不像训练集和测试集，它是非必需的。如果不需要调整超参数，就可以不使用验证集，直接用测试集来评估效果。 验证集评估出来的效果并非模型的最终效果，主要是用来调整超参数的，模型最终效果以测试集的评估结果为准。 测试集 当我们调好超参数后，就要开始「最终考试」了。我们通过测试集（Test Dataset）来做最终的评估。
通过测试集的评估，我们会得到一些最终的评估指标，例如：准确率、精确率、召回率、F1等。
如何合理划分数据集 下面的数据集划分方式主要针对「留出法」的验证方式，除此之外还有其他的交叉验证法，详情见下文 — — 交叉验证法。
数据划分的方法并没有明确的规定，不过可以参考3个原则：
对于小规模样本集（几万量级），常用的分配比例是 60% 训练集、20% 验证集、20% 测试集。 对于大规模样本集（百万级以上），只要验证集和测试集的数量足够即可，例如有 100w 条数据，那么留 1w 验证集，1w 测试集即可。1000w 的数据，同样留 1w 验证集和 1w 测试集。 超参数越少，或者超参数很容易调整，那么可以减少验证集的比例，更多的分配给训练集。 交叉验证法 为什么要用交叉验证法？
假如我们教小朋友学加法：1个苹果+1个苹果=2个苹果
当我们再测试的时候，会问：1个香蕉+1个香蕉=几个香蕉？
如果小朋友知道「2个香蕉」，并且换成其他东西也没有问题，那么我们认为小朋友学习会了「1+1=2」这个知识点。
如果小朋友只知道「1个苹果+1个苹果=2个苹果」，但是换成其他东西就不会了，那么我们就不能说小朋友学会了「1+1=2」这个知识点。
评估模型是否学会了「某项技能」时，也需要用新的数据来评估，而不是用训练集里的数据来评估。这种「训练集」和「测试集」完全不同的验证方法就是交叉验证法。
3 种主流的交叉验证法 留出法（Holdout cross validation） 上文提到的，按照固定比例将数据集静态的划分为训练集、验证集、测试集。的方式就是留出法。
留一法（Leave one out cross validation） 每次的测试集都只有一个样本，要进行 m 次训练和预测。 这个方法用于训练的数据只比整体数据集少了一个样本，因此最接近原始样本的分布。但是训练复杂度增加了，因为模型的数量与原始数据样本数量相同。 一般在数据缺乏时使用。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2020-03-15-socket%E7%BC%96%E7%A8%8B-%E4%B8%80/ class="link black dim">socket编程-一</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">catagories: 计算机网络 description: 计算机网络复习之socket实现(c语言) 什么是socket? 在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。
socket 的典型应用就是 Web 服务器和浏览器：浏览器获取用户输入的URL，向服务器发起请求，服务器分析接收到的URL，将对应的网页内容返回给浏览器，浏览器再经过解析和渲染，就将文字、图片、视频等元素呈现给用户。
学习 socket，也就是学习计算机之间如何通信，并编写出实用的程序。
什么是通信? IP地址和端口能够在广袤的互联网中定位到要通信的程序，协议和数据传输方式规定了如何传输数据，有了这些，两台计算机就可以通信了。
IP地址（IP Address） 计算机分布在世界各地，要想和它们通信，必须要知道确切的位置。确定计算机位置的方式有多种，IP 地址是最常用的，例如，114.114.114.114 是国内第一个、全球第三个开放的 DNS 服务地址，127.0.0.1 是本机地址。
其实，我们的计算机并不知道 IP 地址对应的地理位置，当要通信时，只是将 IP 地址封装到要发送的数据包中，交给路由器去处理。路由器有非常智能和高效的算法，很快就会找到目标计算机，并将数据包传递给它，完成一次单向通信。
端口（Port） 有了 IP 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如Web服务、FTP服务（文件传输服务）、SMTP服务（邮箱服务）等，仅有 IP 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。
为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如，Web服务的端口号是 80，FTP 服务的端口号是 21，SMTP 服务的端口号是 25。
协议（Protocol） 协议（Protocol）就是网络通信的约定，通信的双方必须都遵守才能正常收发数据。协议有很多种，例如 TCP、UDP、IP 等，通信的双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。
协议仅仅是一种规范，必须由计算机软件来实现。例如 IP 协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵守该协议，不能另起炉灶。
所谓协议族（Protocol Family），就是一组协议（多个协议）的统称。最常用的是 TCP/IP 协议族，它包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百个互为关联的协议，由于 TCP、IP 是两种常用的底层协议，所以把它们统称为 TCP/IP 协议族。
数据传输方式 计算机之间有很多数据传输方式，各有优缺点，常用的有两种：SOCK_STREAM 和 SOCK_DGRAM。
SOCK_STREAM(数据流套接字) 表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/2020-03-05-%E6%9F%A5%E7%9C%8Blinux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/ class="link black dim">查看Linux磁盘及内存占用</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">查看Linux磁盘及内存占用 查看磁盘占用 df -k：以KB为单位显示磁盘使用量和占用率
df -m：以Mb为单位显示磁盘使用量和占用率
查看内存占用 1.top
PID：当前运行进程的ID USER：进程属主 PR：每个进程的优先级别 NInice：反应一个进程“优先级”状态的值，其取值范围是-20至19，一 共40个级别。这个值越小，表示进程”优先级”越高，而值越 大“优先级”越低。一般会把nice值叫做静态优先级 VIRT：进程占用的虚拟内存 RES：进程占用的物理内存 SHR：进程使用的共享内存 S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示 该进程优先值为负数 %CPU：进程占用CPU的使用率 %MEM：进程使用的物理内存和总内存的百分比 TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。 COMMAND：进程启动命令名称
２.free
total : 总计物理内存的大小。 used : 已使用多大。 free : 可用有多少。 Shared : 多个进程共享的内存总额。 Buffers/cached : 磁盘缓存的大小。 -/+ buffers/cached) : used:已使用多大; free:可用有多少。
4.ps aux –sort -rss ps aux: 列出目前所有的正在内存当中的程序。</div></div></div></div></section><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/posts/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/3/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://arthuryunze.github.io/>&copy; Yunze's blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>
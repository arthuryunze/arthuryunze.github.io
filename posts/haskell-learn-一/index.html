<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Haskell-learn-一 | Yunze's blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="categories: ProgramLanguage Haskell description: Function program learning Types and Typeclasses ghci 交互式shell中，:t判断变量类型。
:t 'a' 'a' :: Char :: is read as &ldquo;has type of&rdquo;.
函数类型显式声明 一般来说，Haskell有类型推断系统，不需要我们显式声明。但是，我们定义函数时会使用显式声明的办法。
除了编写非常短的函数之外，这通常被认为是一个好的实践。
This is generally considered to be good practice except when writing very short functions.
addThree :: Int -> Int -> Int -> Int addThree x y z = x + y + z 前三个Int是参数类型，最后一个是输出类型。 参数之间用->分隔，并且参数和返回类型之间没有特殊区别。
product [1..10] 120 1到10的乘积
head takes a list of any type and returns the first element"><meta name=generator content="Hugo 0.101.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Haskell-learn-一"><meta property="og:description" content="categories: ProgramLanguage Haskell description: Function program learning Types and Typeclasses ghci 交互式shell中，:t判断变量类型。
:t 'a' 'a' :: Char :: is read as &ldquo;has type of&rdquo;.
函数类型显式声明 一般来说，Haskell有类型推断系统，不需要我们显式声明。但是，我们定义函数时会使用显式声明的办法。
除了编写非常短的函数之外，这通常被认为是一个好的实践。
This is generally considered to be good practice except when writing very short functions.
addThree :: Int -> Int -> Int -> Int addThree x y z = x + y + z 前三个Int是参数类型，最后一个是输出类型。 参数之间用->分隔，并且参数和返回类型之间没有特殊区别。
product [1..10] 120 1到10的乘积
head takes a list of any type and returns the first element"><meta property="og:type" content="article"><meta property="og:url" content="https://arthuryunze.github.io/posts/haskell-learn-%E4%B8%80/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-01T16:57:58+08:00"><meta property="article:modified_time" content="2020-03-01T16:57:58+08:00"><meta itemprop=name content="Haskell-learn-一"><meta itemprop=description content="categories: ProgramLanguage Haskell description: Function program learning Types and Typeclasses ghci 交互式shell中，:t判断变量类型。
:t 'a' 'a' :: Char :: is read as &ldquo;has type of&rdquo;.
函数类型显式声明 一般来说，Haskell有类型推断系统，不需要我们显式声明。但是，我们定义函数时会使用显式声明的办法。
除了编写非常短的函数之外，这通常被认为是一个好的实践。
This is generally considered to be good practice except when writing very short functions.
addThree :: Int -> Int -> Int -> Int addThree x y z = x + y + z 前三个Int是参数类型，最后一个是输出类型。 参数之间用->分隔，并且参数和返回类型之间没有特殊区别。
product [1..10] 120 1到10的乘积
head takes a list of any type and returns the first element"><meta itemprop=datePublished content="2020-03-01T16:57:58+08:00"><meta itemprop=dateModified content="2020-03-01T16:57:58+08:00"><meta itemprop=wordCount content="262"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Haskell-learn-一"><meta name=twitter:description content="categories: ProgramLanguage Haskell description: Function program learning Types and Typeclasses ghci 交互式shell中，:t判断变量类型。
:t 'a' 'a' :: Char :: is read as &ldquo;has type of&rdquo;.
函数类型显式声明 一般来说，Haskell有类型推断系统，不需要我们显式声明。但是，我们定义函数时会使用显式声明的办法。
除了编写非常短的函数之外，这通常被认为是一个好的实践。
This is generally considered to be good practice except when writing very short functions.
addThree :: Int -> Int -> Int -> Int addThree x y z = x + y + z 前三个Int是参数类型，最后一个是输出类型。 参数之间用->分隔，并且参数和返回类型之间没有特殊区别。
product [1..10] 120 1到10的乘积
head takes a list of any type and returns the first element"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Yunze's blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Haskell-learn-一</h1><time class="f6 mv4 dib tracked" datetime=2020-03-01T16:57:58+08:00>March 1, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><hr><h2 id=description-function-program-learning>categories: ProgramLanguage Haskell
description: Function program learning</h2><h1 id=types-and-typeclasses>Types and Typeclasses</h1><p>ghci 交互式shell中，:t判断变量类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>:</span>t <span style=color:#e6db74>&#39;a&#39;</span> 
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span>
</span></span></code></pre></div><p>:: is read as &ldquo;has type of&rdquo;.</p><h2 id=函数类型显式声明>函数类型显式声明</h2><p>一般来说，Haskell有类型推断系统，不需要我们显式声明。但是，我们定义函数时会使用显式声明的办法。<br>除了编写非常短的函数之外，这通常被认为是一个好的实践。</p><p>This is generally considered to be good practice except when writing very short functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>addThree</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>addThree</span> x y z <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>+</span> z  
</span></span></code></pre></div><p>前三个Int是参数类型，最后一个是输出类型。
参数之间用->分隔，并且参数和返回类型之间没有特殊区别。</p><p><code>product [1..10]</code> 120 1到10的乘积</p><p>head takes a list of any type and returns the first element<br><code>head [1..10]</code> 1 返回列表第一项</p><p>Remember fst? It returns the first component of a pair.<br><code>fst (1,2)</code> 1 返回元组第一项</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>:</span>t fst
</span></span><span style=display:flex><span><span style=color:#a6e22e>fst</span> <span style=color:#f92672>::</span> (a, b) <span style=color:#f92672>-&gt;</span> a
</span></span></code></pre></div><h2 id=类型变量type-variables>类型变量——Type variables</h2><p>Functions that have type variables are called polymorphic functions.<br>具有类型变量的函数称为多态函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>:</span>t fst
</span></span><span style=display:flex><span><span style=color:#a6e22e>fst</span> <span style=color:#f92672>::</span> (a, b) <span style=color:#f92672>-&gt;</span> a
</span></span></code></pre></div><p>a,b都不是基本类型，都是类型变量</p><p>基本类型开头字母都是大写。Char Num Fractional</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#66d9ef>Main</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t <span style=color:#e6db74>&#39;a&#39;</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#66d9ef>Main</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Num</span> t <span style=color:#f92672>=&gt;</span> t
</span></span><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#66d9ef>Main</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t <span style=color:#ae81ff>1.1</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1.1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Fractional</span> t <span style=color:#f92672>=&gt;</span> t
</span></span></code></pre></div><h2 id=类型类typeclasses>类型类——Typeclasses</h2><p>实现类似接口的功能</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>:</span>t (<span style=color:#f92672>==</span>)
</span></span><span style=display:flex><span>(<span style=color:#f92672>==</span>) <span style=color:#f92672>::</span> <span style=color:#66d9ef>Eq</span> a <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>:</span>t (elem)
</span></span><span style=display:flex><span>(elem) <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Eq</span> a, <span style=color:#66d9ef>Foldable</span> t) <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
</span></span></code></pre></div><h3 id=常见类型类>常见类型类</h3><p><code>Eq</code>被用来支持类做相等性测试。<br>The functions its members implement are == and /=.<br>它的成员都实现了==和/=（不等）</p><p>所有基本类型都在Eq内（除了IO相关和function）</p><p><code>Ord</code> is for types that have an ordering. Ord covers all the standard comparing functions such as >, &lt;, >= and &lt;=.
有排序的类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t (<span style=color:#f92672>&gt;</span>)  
</span></span><span style=display:flex><span>(<span style=color:#f92672>&gt;</span>) <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Ord</span> a) <span style=color:#f92672>=&gt;</span> a <span style=color:#f92672>-&gt;</span> a <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>  
</span></span></code></pre></div><p>函数compare 有三种返回值GT, LT or EQ, meaning greater than, lesser than and equal</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;Abrakadabra&#34;</span> <span style=color:#f92672>&lt;</span> <span style=color:#e6db74>&#34;Zebra&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>True</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#e6db74>&#34;Abrakadabra&#34;</span> `compare` <span style=color:#e6db74>&#34;Zebra&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>LT</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>True</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>5</span> `compare` <span style=color:#ae81ff>3</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>GT</span>  
</span></span></code></pre></div><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://arthuryunze.github.io/>&copy; Yunze's blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>
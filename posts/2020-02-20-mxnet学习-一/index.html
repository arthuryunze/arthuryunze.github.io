<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>MXNet学习-一 | Yunze's blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="description: Learn MXNet 1 categories: ML MXNet 系统环境：
Windows10
python3
MXNet v1.5.1 cpu版本
Anaconda jupyterLab 1.2.6
国际惯例，从mnist数据集开始。
Loading Data——导入mnist手写体数据集 import mxnet as mx # Fixing the random seed mx.random.seed(42) mnist = mx.test_utils.get_mnist() 注意，Windows环境下，运行完成后将在当前目录下载四个.qz格式文件，若下载被中断，则无法运行后续代码。
解决方法：删除不完整的.qz文件从新下载。Linux系统下该文件位置在~/.keras/datasets路径下，使用命令rm -rf &#34;dataset name&#34;删除。
# 训练批次 batch_size = 100 # 初始化两个迭代器，一个用于训练数据，另一个用于测试数据。 train_data = mx.io.NDArrayIter(mnist['train_data'], mnist['train_label'], batch_size, shuffle=True) val_data = mx.io.NDArrayIter(mnist['test_data'], mnist['test_label'], batch_size) MXNet Data iterators： MXNet数据迭代器
对于大批量数据，不可能预加载整个数据集，MXNet Data iterators可将输入数据流式传输到MXNet训练算法中。
一个批次的图像通常表示为一个4维数组(batch_size, num_channels, width, height)
Approaches——方法(CNN) CNN主要由两种网络层构成：
卷积层和池化层"><meta name=generator content="Hugo 0.101.0"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="MXNet学习-一"><meta property="og:description" content="description: Learn MXNet 1 categories: ML MXNet 系统环境：
Windows10
python3
MXNet v1.5.1 cpu版本
Anaconda jupyterLab 1.2.6
国际惯例，从mnist数据集开始。
Loading Data——导入mnist手写体数据集 import mxnet as mx # Fixing the random seed mx.random.seed(42) mnist = mx.test_utils.get_mnist() 注意，Windows环境下，运行完成后将在当前目录下载四个.qz格式文件，若下载被中断，则无法运行后续代码。
解决方法：删除不完整的.qz文件从新下载。Linux系统下该文件位置在~/.keras/datasets路径下，使用命令rm -rf &#34;dataset name&#34;删除。
# 训练批次 batch_size = 100 # 初始化两个迭代器，一个用于训练数据，另一个用于测试数据。 train_data = mx.io.NDArrayIter(mnist['train_data'], mnist['train_label'], batch_size, shuffle=True) val_data = mx.io.NDArrayIter(mnist['test_data'], mnist['test_label'], batch_size) MXNet Data iterators： MXNet数据迭代器
对于大批量数据，不可能预加载整个数据集，MXNet Data iterators可将输入数据流式传输到MXNet训练算法中。
一个批次的图像通常表示为一个4维数组(batch_size, num_channels, width, height)
Approaches——方法(CNN) CNN主要由两种网络层构成：
卷积层和池化层"><meta property="og:type" content="article"><meta property="og:url" content="https://arthuryunze.github.io/posts/2020-02-20-mxnet%E5%AD%A6%E4%B9%A0-%E4%B8%80/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-20T16:57:58+08:00"><meta property="article:modified_time" content="2020-02-20T16:57:58+08:00"><meta itemprop=name content="MXNet学习-一"><meta itemprop=description content="description: Learn MXNet 1 categories: ML MXNet 系统环境：
Windows10
python3
MXNet v1.5.1 cpu版本
Anaconda jupyterLab 1.2.6
国际惯例，从mnist数据集开始。
Loading Data——导入mnist手写体数据集 import mxnet as mx # Fixing the random seed mx.random.seed(42) mnist = mx.test_utils.get_mnist() 注意，Windows环境下，运行完成后将在当前目录下载四个.qz格式文件，若下载被中断，则无法运行后续代码。
解决方法：删除不完整的.qz文件从新下载。Linux系统下该文件位置在~/.keras/datasets路径下，使用命令rm -rf &#34;dataset name&#34;删除。
# 训练批次 batch_size = 100 # 初始化两个迭代器，一个用于训练数据，另一个用于测试数据。 train_data = mx.io.NDArrayIter(mnist['train_data'], mnist['train_label'], batch_size, shuffle=True) val_data = mx.io.NDArrayIter(mnist['test_data'], mnist['test_label'], batch_size) MXNet Data iterators： MXNet数据迭代器
对于大批量数据，不可能预加载整个数据集，MXNet Data iterators可将输入数据流式传输到MXNet训练算法中。
一个批次的图像通常表示为一个4维数组(batch_size, num_channels, width, height)
Approaches——方法(CNN) CNN主要由两种网络层构成：
卷积层和池化层"><meta itemprop=datePublished content="2020-02-20T16:57:58+08:00"><meta itemprop=dateModified content="2020-02-20T16:57:58+08:00"><meta itemprop=wordCount content="213"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="MXNet学习-一"><meta name=twitter:description content="description: Learn MXNet 1 categories: ML MXNet 系统环境：
Windows10
python3
MXNet v1.5.1 cpu版本
Anaconda jupyterLab 1.2.6
国际惯例，从mnist数据集开始。
Loading Data——导入mnist手写体数据集 import mxnet as mx # Fixing the random seed mx.random.seed(42) mnist = mx.test_utils.get_mnist() 注意，Windows环境下，运行完成后将在当前目录下载四个.qz格式文件，若下载被中断，则无法运行后续代码。
解决方法：删除不完整的.qz文件从新下载。Linux系统下该文件位置在~/.keras/datasets路径下，使用命令rm -rf &#34;dataset name&#34;删除。
# 训练批次 batch_size = 100 # 初始化两个迭代器，一个用于训练数据，另一个用于测试数据。 train_data = mx.io.NDArrayIter(mnist['train_data'], mnist['train_label'], batch_size, shuffle=True) val_data = mx.io.NDArrayIter(mnist['test_data'], mnist['test_label'], batch_size) MXNet Data iterators： MXNet数据迭代器
对于大批量数据，不可能预加载整个数据集，MXNet Data iterators可将输入数据流式传输到MXNet训练算法中。
一个批次的图像通常表示为一个4维数组(batch_size, num_channels, width, height)
Approaches——方法(CNN) CNN主要由两种网络层构成：
卷积层和池化层"></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Yunze's blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">MXNet学习-一</h1><time class="f6 mv4 dib tracked" datetime=2020-02-20T16:57:58+08:00>February 20, 2020</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><hr><h2 id=categories-ml-mxnet>description: Learn MXNet 1
categories: ML MXNet</h2><hr><p>系统环境：<br>Windows10<br>python3<br>MXNet v1.5.1 cpu版本<br>Anaconda
jupyterLab 1.2.6</p><hr><p>国际惯例，从mnist数据集开始。</p><h2 id=loading-data导入mnist手写体数据集>Loading Data——导入mnist手写体数据集</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> mxnet <span style=color:#66d9ef>as</span> mx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Fixing the random seed</span>
</span></span><span style=display:flex><span>mx<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>seed(<span style=color:#ae81ff>42</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mnist <span style=color:#f92672>=</span> mx<span style=color:#f92672>.</span>test_utils<span style=color:#f92672>.</span>get_mnist()
</span></span></code></pre></div><p>注意，Windows环境下，运行完成后将在当前目录下载四个.qz格式文件，若下载被中断，则无法运行后续代码。</p><p>解决方法：删除不完整的.qz文件从新下载。Linux系统下该文件位置在~/.keras/datasets路径下，使用命令<code>rm -rf "dataset name"</code>删除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 训练批次</span>
</span></span><span style=display:flex><span>batch_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 初始化两个迭代器，一个用于训练数据，另一个用于测试数据。</span>
</span></span><span style=display:flex><span>train_data <span style=color:#f92672>=</span> mx<span style=color:#f92672>.</span>io<span style=color:#f92672>.</span>NDArrayIter(mnist[<span style=color:#e6db74>&#39;train_data&#39;</span>], mnist[<span style=color:#e6db74>&#39;train_label&#39;</span>], batch_size, shuffle<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>val_data <span style=color:#f92672>=</span> mx<span style=color:#f92672>.</span>io<span style=color:#f92672>.</span>NDArrayIter(mnist[<span style=color:#e6db74>&#39;test_data&#39;</span>], mnist[<span style=color:#e6db74>&#39;test_label&#39;</span>], batch_size)
</span></span></code></pre></div><p><code>MXNet Data iterators</code>： MXNet数据迭代器<br>对于大批量数据，不可能预加载整个数据集，MXNet Data iterators可将输入数据<em>流式传输</em>到MXNet训练算法中。</p><p>一个批次的图像通常表示为一个4维数组(batch_size, num_channels, width, height)</p><h2 id=approaches方法cnn>Approaches——方法(CNN)</h2><p>CNN主要由两种网络层构成：<br>卷积层和池化层</p><h3 id=卷积层>卷积层</h3><p>单个卷积层由一个或多个过滤器组成，每个过滤器起*特征检测器(feature detector)*的作用。</p><p>在训练过程中，CNN<em>学习</em>这些过滤器的适当表示形式(参数)。</p><p>CNN通过应用<em>非线性函数</em>对卷积层的输出进行<em>转换(transform)</em>。</p><h3 id=池化层>池化层</h3><p>A pooling layer serves to make the CNN translation invariant<br>池化层的作用是使CNN转换不变(平移不变性 转化不变性 惰性 降低敏感度)</p><p>即使左/右/上/下移动几个像素，数字仍保持不变</p><p>池化层将一个 $n \times m$ 的小片(区域)缩减为一个值，使网络对空间位置不那么敏感。在CNN的每个conv(+激活)层之后总是包含池化层。</p><h3 id=lenet>LeNet</h3><p>LeNet: a cnn architecture<br>是一个很受欢迎的网络，它可以很好地完成数字分类任务。</p><p>我们将使用与原始LeNet实现稍有不同的版本，将神经元的sigmoid激活替换为tanh激活。</p><h3 id=implementation-on-mxnet>implementation on MXNet</h3><p>一种典型的方法来写你的网络，这种方法是创建一个新类继承gluon.Block</p><p>我们可以通过组合和继承Block类来定义网络。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> mxnet.ndarray <span style=color:#66d9ef>as</span> F
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Net</span>(gluon<span style=color:#f92672>.</span>Block):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        super(Net, self)<span style=color:#f92672>.</span>__init__(<span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>name_scope():
</span></span><span style=display:flex><span>            <span style=color:#75715e># layers created in name_scope will inherit name space</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># from parent layer.</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>conv1 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Conv2D(<span style=color:#ae81ff>20</span>, kernel_size<span style=color:#f92672>=</span>(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>pool1 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>MaxPool2D(pool_size<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>), strides <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>conv2 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Conv2D(<span style=color:#ae81ff>50</span>, kernel_size<span style=color:#f92672>=</span>(<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>5</span>))
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>pool2 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>MaxPool2D(pool_size<span style=color:#f92672>=</span>(<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>), strides <span style=color:#f92672>=</span> (<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>fc1 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>fc2 <span style=color:#f92672>=</span> nn<span style=color:#f92672>.</span>Dense(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>forward</span>(self, x):
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>pool1(F<span style=color:#f92672>.</span>tanh(self<span style=color:#f92672>.</span>conv1(x)))
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>pool2(F<span style=color:#f92672>.</span>tanh(self<span style=color:#f92672>.</span>conv2(x)))
</span></span><span style=display:flex><span>        <span style=color:#75715e># 0 means copy over size from corresponding dimension.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># -1 means infer size from the rest of dimensions.</span>
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> x<span style=color:#f92672>.</span>reshape((<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> F<span style=color:#f92672>.</span>tanh(self<span style=color:#f92672>.</span>fc1(x))
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> F<span style=color:#f92672>.</span>tanh(self<span style=color:#f92672>.</span>fc2(x))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> x
</span></span></code></pre></div><p>我们这里只是定义了前向函数，计算梯度的后向函数是(使用autograd为您)自动定义的。</p><p>现在，创建网络。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>net <span style=color:#f92672>=</span> Net()
</span></span></code></pre></div><p><img src=https://raw.githubusercontent.com/dmlc/web-data/master/mxnet/image/conv_mnist.png alt="First conv + pooling layer in LeNet."></p><p>下一节将开始训练模型。</p><h2 id=reference>Reference:</h2><p><a href=https://mxnet.apache.org/api/python/docs/tutorials/packages/gluon/image/mnist.html>Handwritten Digit Recognition — Apache MXNet documentation</a></p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://arthuryunze.github.io/>&copy; Yunze's blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>
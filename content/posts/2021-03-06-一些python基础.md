---
title: "一些python基础"
date: 2021-03-06T16:57:58+08:00
draft: false
---

# python基础

## 下划线

### 单前导下划线 _var

约定俗成的含义

以单个下划线开头的变量或方法仅供内部使用。

即私有，这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。

### 前置双下划线

私有化属性或方法，无法在外部直接访问（名字重整所以访问不到,只能是允许这个类本身进行访问了。连子类也不可以）

### 前后双下划线

系统定义名字（这就是在python中强大的`魔法方法`），因为变量名`__xxx__`对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。

## 参数传递

如果函数收到的是一个可变对象（比如字典或者列表）的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个不可变对象（比如数字、字符或者元组）的引用，就不能直接修改原始对象－－相当于通过“传值'来传递对象。

python不允许程序员选择采用传值还是传引用。Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。

Python使用按引用传递（pass-by-reference）将参数传递到函数中。如果你改变一个函数内的参数，会影响到函数的调用。这是Python的默认操作。不过，如果我们传递字面参数，比如字符串、数字或元组，它们是按值传递，这是因为它们是不可变的。

## 如何在Python中创建自己的包？

Python中创建包是比较方便的，只需要在当前目录建立一个文件夹，文件夹中包含一个`__init__.py`文件和若干个模块文件，其中`__init__.py`可以是一个空文件，但还是建议将包中所有需要导出的变量放到`__all__`中，这样可以确保包的接口清晰明了，易于使用。

### `__all__`

只有以“from 模块名 import *”形式导入的模块，当该模块设有 `__all__ `变量时，只能导入该变量指定的成员，未指定的成员是无法导入的。

以下两种情况`__all__`不起作用

+ 以“import 模块名”的形式导入模块。
+ 以“from 模块名 import 成员”的形式直接导入指定成员。

## 可变对象与不可变对象

可变对象（比如字典或者列表）

不可变对象（比如数字、字符或者元组）

### 不可变集合（frozenset）

集合是可变的。而不可变集合却不可变

```
myset=frozenset([1,3,2,2])
myset
```

## 深拷贝浅拷贝

### 深拷贝

开辟新的内存空间

```
import copy
b=copy.deepcopy(a)
```

### 浅拷贝要分三种情况进行讨论

1. 拷贝不可变对象：只是增加一个指向原对象的引用，改变会互相影响。

2. 拷贝可变对象(一层结构)：产生新的对象，开辟新的内存空间，改变互不影响。

3. 拷贝可变对象(多层结构)：**产生新的对象，开辟新的内存空间，不改变包含的子对象则互不影响、改变包含的子对象则互相影响。**

```
>>> import copy

>>> a = [1, 2, [3, 4]]
>>> b = copy.copy(a)
>>> b
... [1, 2, [3, 4]]
# 查看两者的内存地址，不同，开辟了新的内存空间
>>> id(b)
1833997596488
>>> id(a)
1833997596424
>>> a is b
... False
# 1.没有对包含的子对象进行修改，另一方关我卵事
a = [1, 2, [3, 4]]    b = [1, 2, [3, 4]]
>>> b.append(5)
>>> a
... [1, 2, [3, 4]]
>>> a.append(6)
>>> b
... [1, 2, [3, 4], 5]
# 2.对包含的子对象进行修改，另一方也随之改变
a = [1, 2, [3, 4]]    b = [1, 2, [3, 4]]
>>> b[2].append(5)
>>> a
... [1, 2, [3, 4, 5]]
>>> a[2].append(6)
>>> b
... [1, 2, [3, 4, 5, 6]]
```

